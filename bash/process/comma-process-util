#!/bin/bash

# This file is part of comma, a generic and flexible library
# Copyright (c) 2011 The University of Sydney
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University of Sydney nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# this script is designed to be included in another script directly, for example:
# source $( type -p comma-process-util )

## @page comma-process-util comma-process-util
# @brief functions used to start background processes, verify their process ids,
# wait for background processes and kill them safely
#
# @section comma_process_util_constants Constants
# @li @link COMMA_PROCESS_KILL_ERROR @endlink
# @li @link COMMA_PROCESS_KILL_NOT_FOUND @endlink
# @li @link COMMA_PROCESS_KILL_REUSED @endlink
# @li @link COMMA_PROCESS_ALARM_EXIT @endlink
#
# @section comma_process_util_functions Functions
# @li @link comma_process_signature @endlink
# @li @link comma_process_kill_trap_exit_ @endlink
# @li @link comma_process_kill_helper_ @endlink
# @li @link comma_process_kill @endlink
# @li @link comma_process_exec @endlink
# @li @link comma_process_validate @endlink
# @li @link comma_process_exec_and_validate @endlink
# @li @link comma_process_timed_wait_alarm @endlink
# @li @link comma_process_set_timed_wait_alarm_detail @endlink
# @li @link comma_process_set_timed_wait_alarm @endlink
# @li @link comma_process_timed_wait @endlink
# @li @link terminate_comma_execute_and_wait @endlink
# @li @link comma_execute_and_wait @endlink
# @li @link comma_wait_for_process_group @endlink

[[ -n "$comma_process_util_include_guard_" ]] && return 0
readonly comma_process_util_include_guard_=1

source $( type -p comma-string-util ) || { echo "$name: cannot source 'comma-string-util'" >&2; exit 1; }

## @page comma_process_signature comma_process_signature
# @description parse /proc/{pid} directory to build a unique descriptor
# of the process with the given process id. Safe to call from the process
# itself. If called from outside, the caller must make sure that the process
# in question does not disappear mid-call, most typically, send it SIGSTOP
# and ensure that SIGCONT is issued even if the caller itself terminates
# abruptly, such as killed by signal. The signature is written to stdout.
# @param pid process id to query
# @return 0 on success, 1 on error (likely, given PID does not exist),
function comma_process_signature()
{
    trap '' TERM HUP INT PIPE
    local verbose=0
    local pid=$1
    [[ "$pid" == "--verbose" ]] && { verbose=1 ; shift ; pid=$1 ; }
    # do not change to [[ ]] here
    if [ "$pid" -eq "$pid" ] ; then :; else builtin echo "$FUNCNAME: pid '$pid' is not an integer" >&2; return 1; fi
    local stat readexit
    read -a stat < /proc/$pid/stat
    readexit=$?
    (( $readexit == 0 )) || { builtin echo "$FUNCNAME: failed to read /proc/$pid/stat, exit status '$readexit'" >&2; return 1; }
    # use process starttime as signature, see proc(5)
    local signature=${stat[21]}
    [[ -n "$signature" ]] || { builtin echo "$FUNCNAME: no signature for pid '$pid'" >&2; return 1; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: process '$pid' signed as '$signature'" >&2
    echo "$signature"
}
export -f comma_process_signature
declare -r comma_process_signature

## @page COMMA_PROCESS_KILL_ERROR COMMA_PROCESS_KILL_ERROR
# @brief exit status of @link comma_process_kill @endlink in case of internal errors
export COMMA_PROCESS_KILL_ERROR=1
declare -r COMMA_PROCESS_KILL_ERROR

## @page COMMA_PROCESS_KILL_NOT_FOUND COMMA_PROCESS_KILL_NOT_FOUND
# @brief exit status of @link comma_process_kill @endlink if the process to be killed is not in the process tree (terminated already)
export COMMA_PROCESS_KILL_NOT_FOUND=3
declare -r COMMA_PROCESS_KILL_NOT_FOUND

## @page COMMA_PROCESS_KILL_REUSED COMMA_PROCESS_KILL_REUSED
# @brief exit status of @link comma_process_kill @endlink if the process to be killed shows a different signature (PID reused)
export COMMA_PROCESS_KILL_REUSED=4
declare -r COMMA_PROCESS_KILL_REUSED

## @page comma_process_kill_trap_exit_ comma_process_kill_trap_exit_
# @brief auxiliary, the exit trap for @link comma_process_helper_ @endlink
function comma_process_kill_trap_exit_()
{
    (( verbose == 1 )) && builtin echo "$FUNCNAME: send CONT to $pid" >&2
    builtin kill -CONT $pid
}
export -f comma_process_kill_trap_exit_
declare -r comma_process_kill_trap_exit_

## @page comma_process_kill_helper_ comma_process_kill_helper_
# @description check if the given process id has the given descriptor
# (see @link comma_process_signature @endlink) and kill it with TERM if so.
# Does nothing if the process is not found.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param signal-to-use optional; if equal to '--signal=SIGNAL', use SIGNAL as kill argument; otherwise taken as first argument
# @param pid process id to query; start with '-' to kill the process group
# @param signature unique process descriptor to compare
# @return 0 on success (process found, signature matched, process killed), @link COMMA_PROCESS_KILL_NOT_FOUND @endlink
# on internal errors (cannot determine current process signature), @link COMMA_PROCESS_KILL_NOT_FOUND @endlink
# if the process is not found (already terminated), and @link COMMA_PROCESS_KILL_REUSED @endlink on signature mismatch;
# the last two cases may or may not be errors, only the user knows if the process being
# killed is expected to exist or can exit by itself before calling this function
function comma_process_kill_helper_()
{
    # to be invoked in a subshell, do not bother with local variables
    verbose=0
    signal_to_use="TERM"
    while true; do
        case $1 in
            --signal=*) signal_to_use=${1#*=};;
            --verbose)  verbose=1;;
            *)          break;;
        esac
        shift
    done
    pid=$1
    # do not change to [[ ]] here
    if [ "$pid" -eq "$pid" ] ; then :; else builtin echo "$FUNCNAME: pid '$pid' is not an integer" >&2; return 1; fi
    signature=$2
    group=${pid:0:1}
    [[ "$group" == "-" ]] && pid=${pid:1} || group=""
    (( verbose == 1 )) && builtin echo "$FUNCNAME: will send signal '$signal_to_use' to ${group}${pid}" >&2
    # examine the corner case: what if PID is reused by ourselves, i.e., we are tasked to kill a process that is long gone and by accident this function runs with the same PID
    # make sure we do this check before sending STOP to ourselves
    local self=$BASHPID
    [[ "$pid" == "$self" ]] && exit $COMMA_PROCESS_KILL_REUSED
    trap 'comma_process_kill_trap_exit_' EXIT
    builtin kill -STOP $pid
    (( $? == 0 )) || { builtin echo "$FUNCNAME: process id '$pid' not found; do not kill, assume terminated by itself" >&2; trap - EXIT; exit $COMMA_PROCESS_KILL_NOT_FOUND; }
    current=$( comma_process_signature $pid )
    (( $? == 0 )) || { builtin echo "$FUNCNAME: cannot get signature of process id '$pid'" >&2; exit $COMMA_PROCESS_KILL_ERROR; }
    [[ "$current" == "$signature" ]] || { builtin echo "$FUNCNAME: process '$pid' has signature '$current' different from expected '$signature'; possibly re-used; refuse to kill" >&2; exit $COMMA_PROCESS_KILL_REUSED; }
    (( verbose == 1 )) && builtin echo "$FUNCNAME: verification passed, do 'kill -$signal_to_use ${group}${pid}'" >&2
    builtin kill -$signal_to_use ${group}${pid}
}
export -f comma_process_kill_helper_
declare -r comma_process_kill_helper_

## @page comma_process_kill comma_process_kill
# @description invokes @link comma_process_kill_helper_ @endlink in a subshell
# to setup a custom EXIT trap
function comma_process_kill()
{
    # subshell to use a different EXIT trap
    bash -c "comma_process_kill_helper_ $*"
}
export -f comma_process_kill
declare -r comma_process_kill

## @page comma_process_exec comma_process_exec
# @description a wrapper to start background processes; immediately after launch writes
# its own PID into a provided FIFO pipe, for the caller to verify, and then exec for the second
# time to run own command line in the same process id. Overall, it is fork-exec-exec process.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param fifo the named pipe to write the own PID into
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
function comma_process_exec()
{
    local self=$BASHPID
    local verbose=0
    local fifo=$1 ; shift
    [[ "$fifo" == "--verbose" ]] && { verbose=1 ; fifo=$1 ; shift ; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: run in PID '$self'" >&2
    [[ -p "$fifo" ]] || { builtin echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    local signature
    signature=$( comma_process_signature $self ) || { builtin echo "$FUNCNAME: cannot get process signature for '$self'" >&2; return 1; }
    local write_timeout=60
    # one process only, no need for comma-timeout-group
    timeout -s TERM -k 10 $write_timeout bash -c "builtin echo \"$self $signature\" > \"$fifo\""
    local rv=$?
    (( rv == 0 )) || { builtin echo "$FUNCNAME: write into the named pipe '$fifo' failed, error $rv" >&2; return $rv; }
    # if the caller has been interrupted, while the process was writing, the fifo could be removed
    # then the write above succeeds, but the result is a file and not a fifo
    [[ -f "$fifo" ]] && { builtin echo "$FUNCNAME: after the write '$fifo' is not a FIFO" >&2; return 1; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: in PID '$self' '$signature': exec '${@}'" >&2
    unset verbose self fifo signature write_timeout
    exec "${@}"
}
export -f comma_process_exec
declare -r comma_process_exec

## @page comma_process_validate comma_process_validate
# @description verify the process id of the background process as returned by bash
# in $! variable and passed through the named pipe. Also, read the signature of the background
# process (calculated in the child itself and passed through the same named pipe) and store it
# in a global variable; the user can contol the variable name through command-line options.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param variable optional; if equal to '--signature-variable=NAME', assign variable NAME to the signature
# of the background process; otherwise taken as first argument; default name: comma_process_child_signature
# @param fifo the named pipe to read PID from
# @param expected the expected process id
function comma_process_validate()
{
    local verbose=0
    local signature_variable_name="comma_process_child_signature"
    while true; do
        case $1 in
            --signature-variable=*) signature_variable_name=${1#*=};;
            --verbose)              verbose=1;;
            *)                      break;;
        esac
        shift
    done
    local fifo=$1
    local expected=$2
    [[ -p "$fifo" ]] || { builtin echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    local pid status signature
    local read_timeout=60
    # http://stackoverflow.com/questions/6448632/read-not-timing-out-when-reading-from-pipe-in-bash
    # Your shell is blocking on the open() call before invoking the read builtin.
    #
    # On Linux, you can open the FIFO for both read and write at the same time to prevent blocking on open; this is non-portable, but may do what you want.
    (( verbose == 0 )) || builtin echo "$FUNCNAME: attempt to read pid from '$fifo' for $read_timeout seconds ..." >&2
    read -t $read_timeout pid signature <> "$fifo"
    status=$?
    (( status == 0 )) || {
        builtin echo "$FUNCNAME: could not read process id from '$fifo' in $read_timeout seconds or read error, status '$status'" >&2
        return 1
    }
    [[ "$pid" == "$expected" ]] || {
        builtin echo "$FUNCNAME: expected to get a pid of '$expected', but read '$pid'" >&2
        return 1
    }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: expected pid '$expected', read pid '$pid'; success" >&2
    eval "$signature_variable_name=$signature"
    return 0
}
export -f comma_process_validate
declare -r comma_process_validate

## @page comma_process_exec_and_validate comma_process_exec_and_validate
# @description launch the given command as a background process and verify its pid
# by passing it through a fifo and checking against $! variable. If verification passed,
# the value still stored in $! is safe to use. Note that if a signal interrupt occurs
# before or during verification, nothing is certain about $! and reliable signal handlers
# shall bluntly kill all child processes.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param variable optional, see @link comma_process_validate @endlink for details
# @param fifo named pipe to use for passing PID from background process to verifier
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
# @return 0 on verification success, 1 on failure
function comma_process_exec_and_validate()
{
    local args=
    local verbose=
    while true; do
        case $1 in
            --signature-variable=*) args+=" $1";;
            --verbose)              args+=" $1"; verbose+="$1";;
            *)                      break;;
        esac
        shift
    done
    local fifo=$1 ; shift
    [[ -p "$fifo" ]] || { builtin echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    local child
    comma_process_exec $verbose "$fifo" "$@" & child=$!
    comma_process_validate $args "$fifo" "$child"
}
export -f comma_process_exec_and_validate
declare -r comma_process_exec_and_validate

## @page comma_process_timed_wait_alarm comma_process_timed_wait_alarm
# @description raise the alarm (signal ALRM) to wake up the process that called
# @link comma_process_timed_wait @endlink; if the caller process is not found, no signal is sent
# @param verbosity optional: if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param time time to alarm (delay, seconds)
# @param pid process id of the caller (who waits for the wake up call)
# @param signature the signature of the caller obtained using @link comma_process_signature @endlink
# @return none; the function shall be called as a "grandchild" process with no connection
# to the caller and, consequently, no way to collect the exit status
function comma_process_timed_wait_alarm()
{
    local verbose=
    local time=$1
    [[ "$time" == "--verbose" ]] && { verbose="--verbose"; shift ; time=$1; }
    local caller=$2
    local signature=$3
    sleep $time
    comma_process_kill $verbose --signal=ALRM $caller $signature
}
export -f comma_process_timed_wait_alarm
declare -r comma_process_timed_wait_alarm

## @page comma_process_set_timed_wait_alarm_detail comma_process_set_timed_wait_alarm_detail
# @description helper of @link comma_process_set_timed_wait_alarm @endlink; runs the alarm
# function @link comma_process_timed_wait_alarm @endlink as a background process in a separate
# group, then terminates (leaving the child orphaned), thus severing all possible connections
# between the process setting the alarm and the alarm function
# @param same as @link comma_process_timed_wait_alarm @endlink
function comma_process_set_timed_wait_alarm_detail()
{
    # timeout just to send everything into a separate process group
    local forever="4294967296d"
    # do not bother about PID verification, no-one is supposed to wait for this process
    comma-timeout-group --wait-for-process-group 10 -s TERM $forever bash -c "comma_process_timed_wait_alarm $*" &
}
export -f comma_process_set_timed_wait_alarm_detail
declare -r comma_process_set_timed_wait_alarm_detail

## @page comma_process_set_timed_wait_alarm comma_process_set_timed_wait_alarm
# @description prepare the timed alarm; gets the signature for safe kill, sets the trap,
# and launches @link comma_process_timed_wait_alarm @endlink as an orphaned grandchild
# @param verbosity, options: if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param time time to alarm (delay, seconds)
function comma_process_set_timed_wait_alarm()
{
    local verbose=
    local alarm_time=$1
    [[ "$alarm_time" == "--verbose" ]] && { verbose="--verbose"; shift ; alarm_time=$1; }
    local self=$BASHPID
    local signature
    signature=$( comma_process_signature $verbose $self )
    trap ':' ALRM
    # do not bother about PID verification, no-one is supposed to wait for this process
    comma_process_set_timed_wait_alarm_detail $verbose $alarm_time $self $signature </dev/null >/dev/null 2>&1 &
    [[ -z "$verbose" ]] || builtin echo "$FUNCNAME: going to wait for $alarm_time s in PID $self ..." >&2
}
export -f comma_process_set_timed_wait_alarm
declare -r comma_process_set_timed_wait_alarm

## @page COMMA_PROCESS_ALARM_EXIT COMMA_PROCESS_ALARM_EXIT
# @brief exit status of a process terminated by or wait statement interrupted by SIGALRM
export COMMA_PROCESS_ALARM_EXIT=$( temp=$( kill -l ALRM ); (( temp+=128 )) ; echo $temp )
declare -r COMMA_PROCESS_ALARM_EXIT

## @page comma_process_timed_wait comma_process_timed_wait
# @description bash wait builtin lacks a timeout option; this function fills the gap
# @param verbosity, options: if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param time time to alarm (delay, seconds)
# @return exit status of the wait statement that is @link COMMA_PROCESS_ALARM_EXIT @endlink if the wait
# was interrupted by timeout and the exit status of the child process, whatever that is, otherwise
function comma_process_timed_wait()
{
    local verbose=
    local alarm_time=$1
    [[ "$alarm_time" == "--verbose" ]] && { verbose="--verbose"; shift ; alarm_time=$1; }
    local self=$BASHPID
    comma_process_set_timed_wait_alarm $verbose $alarm_time
    wait
    local wrv=$?
    [[ -z "$verbose" ]] || {
        (( $wrv == $COMMA_PROCESS_ALARM_EXIT )) && {
            builtin echo "$FUNCNAME: woken up by alarm, some children have not terminated" >&2
        } || {
            builtin echo "$FUNCNAME: children terminated by themselves, exiting" >&2
        }
    }
    return $wrv
}
export -f comma_process_timed_wait
declare -r comma_process_timed_wait

## @page terminate_comma_execute_and_wait terminate_comma_execute_and_wait
# @brief This is a signal handler used by @link comma_execute_and_wait @endlink.
# See that function for detail.
# @param group true if the background task is a separate process group to be killed altogether; false otherwise
# @param signal name of the signal received; mostly used for debugging
function terminate_comma_execute_and_wait()
{
    trap '' SIGTERM SIGINT SIGHUP SIGPIPE       # temporarily ignore signals
    local usepg=$1
    local killsign="-"
    [[ "$usepg" == "false" ]] && killsign=""
    local received_signal=$2
    local cew_pid=$BASHPID
    local cew_funcname="comma_execute_and_wait ($cew_pid)"
    local termination_signal="TERM"
    [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: interrupted by $received_signal, killsign='$killsign'" >&2

    # kill the command(s) being executed
    if (( cew_verified_pids != 1 )) ; then
        echo "$cew_funcname: terminated before verifying PIDs; kill all child processes instead" >&2
        pkill -$termination_signal -P $cew_pid
        wait
    else
        local command_to_execute_index
        for command_to_execute_index in ${!commands_to_execute_pgid[@]} ; do
            if [[ -n "${commands_to_execute_pgid[$command_to_execute_index]}" ]] ; then
                [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: killing ${commands_to_execute_pgid[$command_to_execute_index]} by $termination_signal" >&2
                comma_process_kill $cew_verbose_flag --signal=$termination_signal ${killsign}${commands_to_execute_pgid[$command_to_execute_index]} ${commands_to_execute_signature[$command_to_execute_index]}
                # ignore the not found and reused exit status: the original process is gone, multiple background processes can terminate at different times
                (( $? == COMMA_PROCESS_KILL_ERROR )) && {
                    echo "$cew_funcname: error in comma_process_kill $cew_verbose_flag --signal=$termination_signal ${killsign}${commands_to_execute_pgid[$command_to_execute_index]} ${commands_to_execute_signature[$command_to_execute_index]}" >&2
                    echo "$cew_funcname: kill all child processes instead" >&2
                    pkill -$termination_signal -P $cew_pid
                    wait
                }
                [[ "$killsign" == "-" ]] && {
                    [[ $call_comma_wait_for_process_group -ne 0 ]] && {
                        [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: waiting for group ${commands_to_execute_pgid[$command_to_execute_index]}" >&2
                        comma_wait_for_process_group "$cew_funcname" "${commands_to_execute_pgid[$command_to_execute_index]}" 25
                    }
                }
                wait ${commands_to_execute_pgid[$command_to_execute_index]}
                [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: group ${commands_to_execute_pgid[$command_to_execute_index]} was terminated" >&2
                commands_to_execute_pgid[$command_to_execute_index]=""
            fi
        done
    fi
    # remove the fifo, if created locally
    [[ "$rm_pid_fifo" == "true" ]] && rm -f "$pid_fifo"
    # use old handlers
    [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo -e "$cew_funcname: restore old traps\n$comma_execute_and_wait_saved_traps\n" >&2
    eval "$comma_execute_and_wait_saved_traps"
    unset comma_execute_and_wait_saved_traps
    # for signals that have no defined old traps, restore the default handlers
    local current_signal current_trap
    for current_signal in SIGTERM SIGINT SIGHUP SIGPIPE ; do
        current_trap=$( trap -p | grep "$current_signal" | cut -d' ' -f3 )
        [[ "$current_trap" == "''" ]] && {
            [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: restore default handler for $current_signal">&2
            trap '-' $current_signal
        }
    done
    [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: re-raise $received_signal" >&2
    kill -$received_signal $cew_pid           # relinguish control
}
export -f terminate_comma_execute_and_wait
declare -r terminate_comma_execute_and_wait

## @page comma_execute_and_wait comma_execute_and_wait
# @description runs a given command as a background task and waits for it to terminate
#
# Usage:
#   comma_execute_and_wait command[ command2[ command3]] [--signals=signal1,signal2,...] \
#                          [--max-wait=max_wait] [--process|--group] [--any|--all] \
#                          [--pid-fifo=<named pipe>]
# Quick example:
#   function _hello() { echo "hello $1"; }
#   export -f _hello
#   comma_execute_and_wait --group "some-command-line-util --some-option" "bash -c _hello world"
#
# The function executes the given command(s) (non-option argument) in a background process(es)
# and waits for its completion (or timeout, see below).
#
# Summary of options:
#     --signals=|--signal-list=    list the signals to trap
#     --fifo=|--pid-fifo=          use the user-provided fifo for comma_process_exec
#     --max-wait=|--timeout=       maximal wait time
#     --group                      run commands in separate groups
#     --process                    run commands in the same group
#     --all                        all commands must succeed
#     --any                        at least one command must succeed
#     --show-debug-messages        talk a lot
#
# Any other argument starting with '-' is an error.
#
# Any other argument is interpreted as a command to be executed. Enquote commands taking
# arguments into a single string.
#
# The command given to be executed inherits from the original process its environment variables
# but not the shell variables. Therefore, the command must be a self-contained string that can be
# used "as-is":
# - if it is a bash function, this function shall be 'export -f'-ed
# - if the command is a bash function, it shall be prepended with "bash -c"
# - if this bash function calls other functions, those shall be either 'export -f'-ed or sourced
#   anew
# - if some variables are used within a function / script, those variables shall be exported
# - the command shall not contain pipes, output redirection and such; wrap pipelines into functions
#   or scripts; pass the output file name into the function / script being executed and redirect
#   inside
# - etc.
#
# Usually the given command is executed in a separate process group. If the caller is interrupted
# by a signal, the entire process group is terminated. Alternatively, the command may be executed
# as a background process in the same process group. If so, the command may need to provide more
# elaborate signal handling so that a signal sent to a single process would terminate the entire
# process tree, if any. Use '--process' to run the command without creating a new process group
# ('--group', the default).
#
# The '--signals' option specifies signals to wait for. Default is INT,HUP,TERM (signals are
# given as comma-separated list of names). If any of the specified signals arrives, the command
# (process or process group) being executed is killed by the same signal, the signal traps are
# restored to their state prior to the entry into comma_execute_and_wait, and the same signal is
# re-raised (sent to itself), possibly triggering one of the restored traps.
#
# Note that if any of your functions is invoked under bash you may not receive the signal you
# expect (the one you sent earlier to terminate the function being executed). Bash may (likely
# will) intercept the original signal and sent HUP to the process running under it. Thus, your
# code shall be always prepared to handle HUP.
#
# If the custom timeout is provided (in time units and format understood by timeout (1) utility)
# and the command-to-execute takes longer, it is terminated by SIGTERM, traps are restored, and
# the function returns 1. The default timeout is 4294967296 days (about 10 million years),
# effectively infinite. The timeout option is available only in '--group' mode. This option is
# incompatible with '--process' mode.
#
# If multiple commands are given, they are all started in parallel. To avoid system overload,
# the user may write a custom script to invoke comma_execute_and_wait in combination with xargs.
# The unit test in "parallel" directory provides a code template. You shall provide a way to
# distribute signals to all instances to comma_execute_and_wait that are used in this fashion.
#
# To ensure that the correct process ids (PIDs) of the background processes are used, the PIDs
# are confirmed by passing them back from the child process through a named pipe. The pipe can
# be specified by the user through '--fifo' option. If none given, a temporary named pipe is
# created and removed after use.
#
# The exit code of comma_execute_and_wait equals the exit code of the command-to-execute
# accounting for possible signal handling. If multiple commands are given, the exit code
# by default is zero if all commands succeed, and one if any fails. This can be explicitly
# enforced by '--all' option. If '--any' option is given, however, the exit code is zero
# if at least one command succeeded, and one if all of them fail.
#
# If the function receives a fatal signal early in the execution when it launches background
# processes, it may not capture all the children process ids. In this case, all child processes
# of the caller will be terminated.
#
# Similar, if the function encounters an internal error and cannot terminate the child process
# in the usual way, it resorts to killing all child processes as a fallback.
#
# To avoid these corner cases, this function is best used when the caller has no other background
# children created beforehand.
#
# @param command commands to execute or options; see the detailed description above
function comma_execute_and_wait()
{
    # store existing traps for restoring on exit
    comma_execute_and_wait_saved_traps=$( trap )
    local cew_pid=$BASHPID
    local cew_funcname="comma_execute_and_wait ($cew_pid)"

    # defaults
    local signal_list="TERM,INT,HUP"
    local commands_to_execute=()
    # timeout default is very long time, essentially, forever
    local execute_and_wait_timeout="4294967296d"
    local timeout_given="false"

    # process arguments
    local original_args="$@"
    local usepg="true"
    local statusall="true"
    local comma_execute_and_wait_verbose="false" # "true"
    local cew_verbose_flag=
    local pid_fifo=
    local rm_pid_fifo="false"
    local cew_verified_pids=0
    while [[ $# -ne 0 ]]; do
        case $1 in
            --signals=*|--signal-list=*) signal_list=${1#*=};;
            --fifo=*|--pid-fifo=*)       pid_fifo=${1#*=};;
            --max-wait=*|--timeout=*)    execute_and_wait_timeout=${1#*=} ; timeout_given="true";;
            --group)                     usepg="true";;
            --process)                   usepg="false";;
            --all)                       statusall="true";;
            --any)                       statusall="false";;
            --show-debug-messages)       comma_execute_and_wait_verbose="true";;
            -*)                          echo "$cew_funcname: unknown option '$1' (called: comma_execute_and_wait $original_args)" >&2; return 1;;
            *)                           commands_to_execute+=( "$1" );;
        esac
        shift
    done
    if [[ "$usepg" == "false" && "$timeout_given" == "true" ]] ; then
        echo "$cew_funcname: conflicting timeout and process options (called: comma_execute_and_wait $original_args)" >&2
        return 1
    fi
    [[ "$comma_execute_and_wait_verbose" == "true" ]] && cew_verbose_flag="--verbose"

    [[ -n "$pid_fifo" ]] && {
        [[ -p "$pid_fifo" ]] || { echo "$cew_funcname: fifo argument '$pid_fifo' is not a named pipe" >&2; return 1; }
    }

    # set up a new signal handler / trap that:
    # - determines the signal being sent so that the same signal can be re-raised
    # - if the command-to-execute is running, kill its process group
    # - restores the traps
    # - re-sends the trapped signal to itself
    [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo -e "$cew_funcname: saved traps are:\n${comma_execute_and_wait_saved_traps[@]}" >&2
    local signal_to_handle
    for signal_to_handle in ${signal_list//,/ } ; do
        [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: setting trap on '$signal_to_handle'" >&2
        trap 'terminate_comma_execute_and_wait $usepg $signal_to_handle' $signal_to_handle
    done
    [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo -e "$cew_funcname: newly-set traps are:\n$( trap -p )" >&2

    # if not given explicitly, create a temporary PID fifo
    [[ -n "$pid_fifo" ]] || {
        rm_pid_fifo="true"
        pid_fifo=$( mktemp --dry-run --tmpdir="$TMPDIR" comma_execute_and_wait.pid_fifo.XXXXXXXX )
        [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: creating a temporary named pipe '$pid_fifo'" >&2
        mkfifo "$pid_fifo" || { echo "$cew_funcname: cannot create named pipe '$pid_fifo'" >&2; return 1; }
    }

    local commands_to_execute_pgid=()
    local commands_to_execute_signature=()
    local commands_to_execute_status=0
    comma-timeout-group --can-wait-for-process-group
    local call_comma_wait_for_process_group=$?
    [[ "$statusall" == "false" ]] && commands_to_execute_status=1

    local command_to_execute cmd shellfcn
    for command_to_execute in "${commands_to_execute[@]}" ; do
        [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: got command '$command_to_execute'" >&2
        # shell functions require special handling due to quote spaces
        command_to_execute=$( comma_trim "$command_to_execute" )
        cmd=$( shopt -s extglob ; cmd=${command_to_execute##bash*( )-c*( )}; echo "$cmd" )
        if [[ "$cmd" != "$command_to_execute" ]] ; then
            shellfcn="true"
            command_to_execute="$cmd"
        fi

        # run the command-to-execute as a background process or as a background job in
        # its own process group and under timeout
        if [[ "$usepg" == "true" ]] ; then
            [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: execute commands as process groups" >&2
            if [[ "$shellfcn" == "true" ]] ; then
                comma_process_exec_and_validate $cew_verbose_flag "$pid_fifo" comma-timeout-group $cew_verbose_flag --wait-for-process-group 25 -s TERM $execute_and_wait_timeout bash -c "$command_to_execute"
            else
                comma_process_exec_and_validate $cew_verbose_flag "$pid_fifo" comma-timeout-group $cew_verbose_flag --wait-for-process-group 25 -s TERM $execute_and_wait_timeout $command_to_execute
            fi
        else
            [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: execute commands as processes" >&2
            if [[ "$shellfcn" == "true" ]] ; then
                comma_process_exec_and_validate $cew_verbose_flag "$pid_fifo" bash -c "$command_to_execute"
            else
                comma_process_exec_and_validate $cew_verbose_flag "$pid_fifo" $command_to_execute
            fi
        fi
        (( $? == 0 )) || {
            echo "$cew_funcname: terminating self on fatal system error; incorrect background PID reported; re-run your application" >&2
            kill -TERM $cew_pid  # go into our signal handler
        }
        commands_to_execute_pgid+=( $! )
        commands_to_execute_signature+=( $comma_process_child_signature )
    done
    cew_verified_pids=1
    # do not need it anymore
    [[ "$rm_pid_fifo" == "true" ]] && { rm -f "$pid_fifo"; unset pid_fifo; rm_pid_fifo="false"; }

    # wait for the completion of the subprocess(es)
    local command_to_execute_status command_to_execute_index
    for command_to_execute_index in ${!commands_to_execute_pgid[@]} ; do
        wait ${commands_to_execute_pgid[$command_to_execute_index]}
        command_to_execute_status=$?
        (( command_to_execute_status == 127 )) && {
            echo "$cew_funcname: fatal system error, wait exit status is 127 on the process id ${commands_to_execute_pgid[$command_to_execute_index]}" >&2
            echo "$cew_funcname: all background process ids ${commands_to_execute_pgid[@]} have been verified" >&2
            echo "$cew_funcname: the process tree of $cew_pid:" >&2
            pstree -a -c -g -l -p $cew_pid >&2
            echo "$cew_funcname: this is likely a rare internal error in bash; re-run your application" >&2
            statusall="true"
            commands_to_execute_status=1
            # keep going to let the other processes to complete
        }
        # special care when process group has been killed by timeout itself
        [[ "$usepg" == "true" && $call_comma_wait_for_process_group -ne 0 ]] && comma_wait_for_process_group "$cew_funcname" "${commands_to_execute_pgid[$command_to_execute_index]}" 25
        [[ "$comma_execute_and_wait_verbose" == "true" ]] && echo "$cew_funcname: group ${commands_to_execute_pgid[$command_to_execute_index]} finished execution, status $command_to_execute_status" >&2
        commands_to_execute_pgid[$command_to_execute_index]=""
        if (( ${#commands_to_execute[@]} == 1 )) ; then
            # use as-is
            commands_to_execute_status=$command_to_execute_status
        else
            # accumulate
            if [[ "$statusall" == "true" ]] ; then
                (( $command_to_execute_status == 0 )) || commands_to_execute_status=1
            else
                (( $command_to_execute_status == 0 )) && commands_to_execute_status=0
            fi
        fi
    done
    # restore traps
    trap - ${signal_list//,/ } ; eval "$comma_execute_and_wait_saved_traps"; unset comma_execute_and_wait_saved_traps
    # return the wait outcome
    return $commands_to_execute_status
}
export -f comma_execute_and_wait
declare -r comma_execute_and_wait

## @page comma_wait_for_process_group comma_wait_for_process_group
# @description likely a workaround for a problem encountered in bash-4.3 series:
# the builtin "wait" failed to wait for all processes in a (killed) process group to terminate;
# this function would poll the process list for the given time (or forever) until no processes are left
# creates a race condition in case of PID re-use; shall not be called if customized version of
# timeout (aka comma-timeout-group) is used.
# @param name name of the caller, used only for trace messages
# @param pgid process group id to wait for
# @param max_wait the maximal time to wait or "forever"; if this timeout is reached, the function "kill -9" the entire group
# @return 0 if processes ended by themselves and 1 if kill-9-ed
function comma_wait_for_process_group()
{
    local caller_name=$1
    local process_group_id=$2
    local max_wait_time=$3
    [[ -n "$max_wait_time" ]] || max_wait_time="forever"
    local iter=0
    local leftovers leftovers_count leftovers_rv
    local user=$USER
    [[ -n $user ]] || user=$(id -un)
    while true ; do
        if [[ "$max_wait_time" != "forever" ]] ; then
            (( iter > max_wait_time )) && {
                echo "$caller_name: exceeded ${max_wait_time}s timeout in waiting for $process_group_id" >&2
                echo "$name: kill -9 process group $process_group_id" >&2
                kill -KILL -- -"$process_group_id"
                return 1
            }
        fi
        # occasionally observed ps hanging here indefinitely; single process, no need for timeout-group
        leftovers=$( timeout -k 10 -s TERM 10 ps --no-headers -u $user -o pgid,pid,comm | grep "^ *$process_group_id " | grep -v '<defunct>' )
        leftovers_rv=$?
        (( leftovers_rv >= 126 )) && { echo "$caller_name: could not list processes in group $process_group_id (status '$leftovers_rv')" >&2; (( ++iter )); sleep 1; continue; }
        leftovers_count=$( echo "$leftovers" | sed '/^$/d' | wc -l )
        leftovers=$( echo -n "$leftovers" | tr '\n' ',' )
        (( leftovers_count > 0 )) && { echo "$caller_name: waited ${iter}s for $process_group_id, still $leftovers_count processes left ('$leftovers')" >&2; sleep 1; } || { return 0; }
        (( ++iter ))
    done
}
export -f comma_wait_for_process_group
declare -r comma_wait_for_process_group
